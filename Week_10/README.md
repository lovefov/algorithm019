
# 算法总结

## 刻意练习–过遍数

## 切题四件套

- clarification
- possible solutions
- compare（time/space）
- optimal（学习最优解加强）
- coding（多写）
- test cases

## 五遍刷题法：
- 练习缺点、弱点地方，不舒服、枯燥、不爽—就是在进步；

- ①刷题第一遍

5-15分钟：读题+思考
直接看解法：注意看多解法、比较解法优劣
背诵、默写好的解法。
- ②刷题第二遍

马上自己写 -->leetcode提交
多种解法，体会优劣；
- ③刷题第三遍

过了一天后在重复做题
- ④刷题第四遍

过了一周后：反复回来练习相同题目
- ⑤刷题第五遍

## 面试前一周准备
3、递归 Recursion
递归 – 循环
通过函数体来进行循环
四个条件：

* 递回终止条件
* 处理当前层逻辑
* 下探到下一层
* 清理当前层
* 思维要求

不要再进行人肉递归（最大误区）
找到最近最简方法，将其拆解成可重复解决的问题（重复子问题）
数学归纳法

## 分治思维：

递归终止条件
拆分子问题
调子问题的递归函数
合并结果，有可能要恢复当前层的状态

## 动态规划
动态规划和递归或者分治，没有根本上的区别（关键看有无最优子结构）
共性：找到重复子问题
差异性：最优子结构，中途可以淘汰次优解

## 动态规划关键点：

最优子结构 optn = best_of(opt n-1, optn-2,....)（子问题）
储存中间状态:opti (状态定义）
递归公式（状态转移方程或者DP方程）
高阶dp

状态拥有更多维度
状态方程更加复杂


## 字典树，Trie
- 字典树，即Trie树，又称单词查找树或键树，是一种数据结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。

- 优点在于：最大限度的减少无谓的字符串比较，查找效率比哈希表高。

- 基本性质：

- 节点本身不存完整单词；
从根节点到某一节点路径上经过的字符链接起来，为该节点的字符串；
每个节点的所有子节点路径代表字符都不相同。
核心思想
Trie树的核心思想就是空间换时间
利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的

## 并查集

* 适用场景

- 组团、配对问题
- 适用场景：组团、配对问题

* 基本操作：

- makeset(s)：建立一个新的并查集，其中包括s个单位元素集合；
- unionset(s):把元素x和y所在的元素集合合并，要求x和y所在的集合不相交，如果相交则不合并；
find(x):找到元素x所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将他们各自的代表比较一下即可；

## LRU Cache缓存

两个要素：大小、替换策略
HashTable + Double LinkedList

## 布隆过滤器

- 本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。

- 相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的

- HashMap 的问题
讲述布隆过滤器的原理之前，我们先思考一下，通常你判断某个元素是否存在用的是什么？应该蛮多人回答 HashMap 吧，确实可以将值映射到 HashMap 的 Key，然后可以在 O(1) 的时间复杂度内返回结果，效率奇高。但是 HashMap 的实现也有缺点，例如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦你的值很多例如上亿的时候，那 HashMap 占据的内存大小就变得很可观了。

还比如说你的数据集存储在远程服务器上，本地服务接受输入，而数据集非常大不可能一次性读进内存构建 HashMap 的时候，也会存在问题。

## 位运算

按位异或的一些特殊情况

`x ^ 1s( 1s表示全1） ~x x^(~x) 1s x ^ x 0 c = a ^ b a ^ c = b， b ^ c =a a ^ b ^ c a ^ (b ^ c) = (a ^ b) ^ c`

指定位置的位运算

获取x的第n位的幂值 x &（1<< (n-1) ） 获取x的第n位值（0或1） （x >> n） & 1 仅将第n位置为1 x |（1 <<n） 仅将第n位置为0 x & (~1 <<n )) 将x最高位至第n位（含）清零 x & （（1<<n）-1） 将第n位至第0位（含）清零 x &(~（（1<<(n+1）-1）)

位运算实际应用

`x % 2 ==1 （x &1）==1 x %2 ==0 （x&1） == 0 x>>1 x/2 x = x&(x-1) 清零最低位的1 x & -x 得到最低位的1 x& ~x 0`

## 排序算法

十种常见排序算法可以分为两大类：

- 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。
- 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。

## 经典题

- 爬楼梯、硬币兑换
- 括号匹配、括号生成、直方图最大面积、滑动窗口
- 二叉树遍历、分层输出树、判断二叉排序树
- 股票买卖系列、偷房子、字符串编辑距离、最长上升子序列、最长公共子序列
- 异位词（判断和归类）、回文串（最大回文串）、regex和通配符匹配
- 高级数据结构（Trie、BloomFilter、LRU catch 、etc）
